'use client'

import { useEffect, useRef, useState } from 'react'
import { MapPin, Crosshair, ZoomIn, ZoomOut } from 'lucide-react'
import { Card } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import 'leaflet/dist/leaflet.css'

type LatLng = { lat: number; lng: number }
type Selected = { lat: number; lng: number; address: string | null }

declare global {
  interface Window {
    Telegram?: any
  }
}

export default function CreateEventView() {
  // --- form state ---
  const [eventName, setEventName] = useState('')
  const [datetimeLocal, setDatetimeLocal] = useState<string>(() => {
    const now = new Date()
    now.setSeconds(0, 0)
    const m = now.getMinutes()
    now.setMinutes(m + ((15 - (m % 15)) % 15))
    return toLocalDatetimeValue(now)
  })

  // --- map state ---
  const mapEl = useRef<HTMLDivElement | null>(null)
  const mapRef = useRef<any>(null)       // Leaflet.Map
  const tileRef = useRef<any>(null)      // Leaflet.TileLayer
  const markerRef = useRef<any>(null)    // Leaflet.Marker
  const [zoomLevel, setZoomLevel] = useState(15)
  const [selected, setSelected] = useState<Selected | null>(null)

  // init map
  useEffect(() => {
    let destroyed = false
    ;(async () => {
      const L = (await import('leaflet')).default

      if (!mapEl.current || destroyed || mapRef.current) return

      // default center (CDMX)
      const center: LatLng = { lat: 19.4326, lng: -99.1332 }
      const map = L.map(mapEl.current, { zoomControl: false }).setView(center, zoomLevel)
      mapRef.current = map

      // primary tiles (single host)
      const primary = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors',
      }).addTo(map)
      tileRef.current = primary

      primary.once('tileerror', () => {
        // fallback provider
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 20,
          subdomains: ['a', 'b', 'c', 'd'],
          attribution: '&copy; OSM &copy; <a href="https://carto.com/attributions">CARTO</a>',
        })
          .addTo(map)
      })

      // click to place/move marker
      map.on('click', (e: any) => setMarker(e.latlng.lat, e.latlng.lng))

      // keep zoomLevel in state
      map.on('zoomend', () => setZoomLevel(map.getZoom()))

      // after Telegram expands
      setTimeout(() => map.invalidateSize(), 0)
    })()

    return () => {
      destroyed = true
      mapRef.current?.remove?.()
      mapRef.current = null
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // marker helpers
  function setMarker(lat: number, lng: number) {
    if (!mapRef.current) return
    import('leaflet').then(({ default: L }) => {
      if (!markerRef.current) {
        markerRef.current = L.marker([lat, lng], { draggable: true }).addTo(mapRef.current)
        markerRef.current.on('dragend', () => {
          const p = markerRef.current.getLatLng()
          updateSelection(p.lat, p.lng)
        })
      } else {
        markerRef.current.setLatLng([lat, lng])
      }
      updateSelection(lat, lng)
    })
  }

  function updateSelection(lat: number, lng: number) {
    const round6 = (n: number) => Math.round(n * 1e6) / 1e6
    const coords = { lat: round6(lat), lng: round6(lng) }
    reverseGeocode(coords).then((address) => {
      setSelected({ ...coords, address })
    })
  }

  async function reverseGeocode({ lat, lng }: LatLng): Promise<string | null> {
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}`
      const res = await fetch(url, { headers: { Accept: 'application/json' } })
      if (!res.ok) return null
      const data = await res.json()
      return data?.display_name || null
    } catch {
      return null
    }
  }

  // ui actions
  const handleZoomIn = () => mapRef.current?.zoomIn()
  const handleZoomOut = () => mapRef.current?.zoomOut()
  const handleLocate = () => {
    if (!navigator.geolocation) return alert('Geolocation not available.')
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude
        const lng = pos.coords.longitude
        mapRef.current?.setView([lat, lng], 16)
        setMarker(lat, lng)
      },
      () => alert('Could not get location. Tap the map to set a pin.'),
      { enableHighAccuracy: true, timeout: 8000 }
    )
  }

  // send payload to bot
  const canSend = eventName.trim().length > 0 && !!datetimeLocal && !!selected
  useEffect(() => {
    const tg = window.Telegram?.WebApp
    if (!tg) return
    tg.ready?.()
    tg.expand?.()
    if (canSend) tg.MainButton?.show?.()
    else tg.MainButton?.hide?.()
    tg.MainButton?.setText?.('Create event')
    tg.MainButton?.onClick?.(() => doSend(tg))
    return () => tg.MainButton?.offClick?.(doSend as any)
  }, [canSend])

  function doSend(tg: any) {
    if (!canSend || !selected) return
    const iso = toIsoFromLocal(datetimeLocal)
    const payload = {
      type: 'create_event',
      data: {
        name: eventName.trim(),
        datetime_local: datetimeLocal,
        datetime_iso: iso,
        tz_offset_minutes: new Date().getTimezoneOffset() * -1,
        location: {
          lat: selected.lat,
          lng: selected.lng,
          address: selected.address ?? null,
        },
      },
    }
    tg.sendData?.(JSON.stringify(payload))
    tg.close?.()
  }

  return (
    <Card className="overflow-hidden shadow-lg border">
      {/* header/fields */}
      <div className="p-4 space-y-3">
        <h2 className="text-base font-semibold">Create Event</h2>
        <div className="grid gap-2">
          <label className="text-sm">Event name</label>
          <input
            className="h-10 rounded-md border px-3 text-sm bg-background"
            value={eventName}
            onChange={(e) => setEventName(e.target.value)}
            placeholder="e.g., Training at La Merced"
          />
        </div>
        <div className="grid gap-2">
          <label className="text-sm">Date &amp; time</label>
          <input
            type="datetime-local"
            className="h-10 rounded-md border px-3 text-sm bg-background"
            value={datetimeLocal}
            onChange={(e) => setDatetimeLocal(e.target.value)}
          />
        </div>
      </div>

      {/* map area */}
      <div className="relative h-80">
        <div ref={mapEl} className="absolute inset-0 rounded-md overflow-hidden" />

        {/* controls (top-right) */}
        <div className="absolute top-3 right-3 flex flex-col gap-2 z-10">
          <Button variant="secondary" size="icon" className="h-9 w-9 border" onClick={handleZoomIn}>
            <ZoomIn className="h-4 w-4" />
          </Button>
          <Button variant="secondary" size="icon" className="h-9 w-9 border" onClick={handleZoomOut}>
            <ZoomOut className="h-4 w-4" />
          </Button>
          <Button variant="secondary" size="icon" className="h-9 w-9 border" onClick={handleLocate}>
            <Crosshair className="h-4 w-4" />
          </Button>
        </div>

        {/* zoom indicator */}
        <div className="absolute bottom-3 left-3 text-xs bg-background/80 backdrop-blur rounded-full px-3 py-1 border">
          Zoom: {zoomLevel}
        </div>
      </div>

      {/* footer / info + send */}
      <div className="p-4 space-y-2">
        <div className="text-xs font-mono">
          Lat: {selected?.lat ?? '—'}, Lng: {selected?.lng ?? '—'}
        </div>
        <div className="text-xs font-mono truncate">
          Address: {selected?.address ?? '—'}
        </div>

        <div className="mt-3 flex gap-2">
          <Button variant="secondary" className="flex-1 border" onClick={handleLocate}>
            Use my location
          </Button>
          <Button className="flex-1" disabled={!canSend} onClick={() => doSend(window.Telegram?.WebApp)}>
            Create event
          </Button>
        </div>
      </div>
    </Card>
  )
}

/* ---------- helpers ---------- */
function toLocalDatetimeValue(d: Date) {
  const pad = (n: number) => String(n).padStart(2, '0')
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`
}

function toIsoFromLocal(localStr: string | null) {
  if (!localStr) return null
  const [date, time] = localStr.split('T')
  const [y, m, dd] = date.split('-').map(Number)
  const [hh, mm] = (time || '00:00').split(':').map(Number)
  const dt = new Date(y, m - 1, dd, hh, mm, 0)
  return dt.toISOString()
}
